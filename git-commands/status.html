<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Status</title>
    <link rel="stylesheet" href="../style.css">
</head>

<body>
    <p> <center> <img width="150"
        src="https://git-scm.com/images/logo@2x.png">
    </center>
</p>
    <h1> status</h1>

    <p>
        The git status command displays the state of the working directory and the staging area. It lets you see which changes have been staged, which haven’t, and which files aren’t being tracked by Git. Status output does not show you any information regarding the committed project history. For this, you need to use git log.
    </p>
    
    <h2>Related git commands</h2>
    <p>
git tag 
    Tags are ref's that point to specific points in Git history. git tag is generally used to capture a point in history that is used for a marked version release (i.e. v1.0.1). 
git blame
    The high-level function of git blame is the display of author metadata attached to specific committed lines in a file. This is used to explore the history of specific code and answer questions about what, how, and why the code was added to a repository.
git log
    The git log command displays committed snapshots. It lets you list the project history, filter it, and search for specific changes. 
    </p>
    
    <h2>Usage</h2>
    <p>
git status

List which files are staged, unstaged, and untracked.
    </p>

    <h2>Options</h2>
    <p> 
    <strong>short</strong>
    <br> Give the output in the short-format.
    <br><strong>branch</strong>
    <br> Show the branch and tracking info even in short-format.
    <br><strong>show-stash</strong>
    <br>Show the number of entries currently stashed away.
    <br><strong>porcelain</strong>
    <br>Give the output in an easy-to-parse format for scripts. This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details. The version parameter is used to specify the format version. This is optional and defaults to the original version v1 format.
    <br><strong>long</strong>
    <br>Give the output in the long-format. This is the default.
    <br><strong>verbose</strong>
    <br>In addition to the names of files that have been changed, also show the textual changes that are staged to be committed (i.e., like the output of git diff --cached). If -v is specified twice, then also show the changes in the working tree that have not yet been staged (i.e., like the output of git diff).
    <br><strong>untracked-files</strong>
    <br>Show untracked files. 
    <br><strong>ignore-submodules</strong>
    <br>Ignore changes to submodules when looking for changes. <when> can be either "none", "untracked", "dirty" or "all", which is the default. Using "none" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config[1] or gitmodules[5]. When "untracked" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using "dirty" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior before 1.7.0). Using "all" hides all changes to submodules (and suppresses the output of submodule summaries when the config option status.submoduleSummary is set).
    <br><strong>The possible options are:</strong>
    <ul>traditional - Shows ignored files and directories, unless --untracked-files=all is specified, in which case individual files in ignored directories are displayed.</ul>
    <ul>no	- Show no ignored files.</ul>
    <ul>matching - Shows ignored files and directories matching an ignore pattern.</ul>
        
                
    <h2>Untracted files and performance</h2>
    <p><em>git status</em> can be very slow in large worktrees if/when it needs to search for untracked files and directories. There are many configuration options available to speed this up by either avoiding the work or making use of cached results from previous Git commands. There is no single optimum set of settings right for everyone. We’ll list a summary of the relevant options to help you, but before going into the list, you may want to run <em>git status</em> again, because your configuration may already be caching <em>git status</em> results, so it could be faster on subsequent runs.
        <ul>
            <li> The <em>--untracked-files=no</em> flag or <em>the status.showUntrackedfiles=false</em> config: indicate that git status should not report untracked files. This is the fastest option. git status will not list the untracked files, so you need to be careful to remember if you create any new files and manually git add them.</li>
            <li><em>advice.statusUoption=false</em><a href="https://git-scm.com/docs/git-config">(see git-config[1])</a>: setting this variable to false disables the warning message given when enumerating untracked files takes more than 2 seconds. In a large project, it may take longer and the user may have already accepted the trade off (e.g. using "-uno" may not be an acceptable option for the user), in which case, there is no point issuing the warning message, and in such a case, disabling the warning may be the best.</li>
            <li><em>core.untrackedCache=true</em><a href="https://git-scm.com/docs/git-update-index">(see git-update-index[1])</a>: enable the untracked cache feature and only search directories that have been modified since the previous git status command. Git remembers the set of untracked files within each directory and assumes that if a directory has not been modified, then the set of untracked files within has not changed. This is much faster than enumerating the contents of every directory, but still not without cost, because Git still has to search for the set of modified directories. The untracked cache is stored in the .git/index file. The reduced cost of searching for untracked files is offset slightly by the increased size of the index and the cost of keeping it up-to-date. That reduced search time is usually worth the additional size.</li>
            <li><em>core.untrackedCache=true</em>and <em>core.fsmonitor=true</em> or <em>core.fsmonitor=hook_command_pathname</hook_command_pathname></em><a href="https://git-scm.com/docs/git-update-index">(see git-update-index[1])</a>: enable both the untracked cache and FSMonitor features and only search directories that have been modified since the previous git status command. This is faster than using just the untracked cache alone because Git can also avoid searching for modified directories. Git only has to enumerate the exact set of directories that have changed recently. While the FSMonitor feature can be enabled without the untracked cache, the benefits are greatly reduced in that case.
    </li>
        </ul>
        
    
    </p>

</body>

</html>